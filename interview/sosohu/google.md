
##电面

>	Large Number Add One: 字符串表示的大正整数，返回其+1后的结果

LC水题

>	Word Break:	给你一个字符串，一个词典，判断该字符串能否被切分成一个个词

LC水题

>	Sorted Matrix Search II:	给你一个方阵，该方阵每行，每列都是从小到大排序好的整数，
>	在这个方阵中查找是否存在某个数

LC题目,我给出的是一种把矩阵切分成两个子问题的做法，面试官希望切分成一个子问题，所以想了一会，后来经过提示才给出了解法

##一轮一面

>	给你一个写好的函数，找出其中低效的代码

主要是把参数改成引用这种，减少拷贝

>	Merge Sort的时间复杂度是多少？　怎么证明?

简单的画了一下推导树

>	有N个查询，编号分别是1,...,N,  每个查询有个权值分别为w1, w2, ... ,wN,  
>	下面我们需要设计一个Rand函数，使得我们执行一次Rand函数，能返回一个查询,
>	要求返回查询i的概率为wi/(w1 + w2 + ... + wN)
>	如果，我们要求执行N次Rand,且这N次产生的查询各不相同，即产生了所有的查询，该怎么办?

遍历一边，逐个计算出概率区间，然后调用rand(1)函数，获得概率值，根据改值找出对应查询，O(N)时间复杂度

对于Follow Up, 我后来说建立线段树，然后不断的从线段树中抽出一个叶子，作为Rand出来的查询，并删除该叶子以防再次被产生，执行N次．时间复杂度为NlgN

##一轮二面

>	自我介绍，说一说自己最拿手的项目

蹩脚的自我介绍，面试官应该也没听明白

>	给你一组二元元素对例如C = {(1, 2), (2, 1),(3, 1),(4, 0),(5, 0)}
>	其中C[i].first与整数无重复数组A的元素一一对应, C[i].second表示
>	数组A中位于C[i].first元素前面且比C[i].first大的元素个数,现在要求
>	求出数组A的各元素值, 例如本例的 A = {4, 2, 1, 3, 5}

最优解法时间复杂度为O(NlgN), 我给出的是这个复杂度，但是解法太复杂，用了很多链表，面试官不是很满意


##结果

一轮游
