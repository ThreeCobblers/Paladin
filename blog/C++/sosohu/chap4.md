#表达式
##求值顺序
运算符有优先级和结合性,但是除了`&&,||,?:和,`这四个运算符以外,都没有规定运算符的操作数的求值顺序

举个例子来说:`cout<<i<<i++<<endl`, <<运算符没有规定求值顺序,所以编译器可以自行决定先算前面那个还是后面那个.

再例如:`f() + g()*h() + j()`,虽然我们知道先计算g*h再计算加,但是f,g,h,j函数调用顺序即求值顺序是由编译器决定的,是不确定的.

还有像:`n=n++`这条语句其实也是未定义的.

Note: 像C语言里面有个经典问题: `printf( "%d%d", i, i++ );`,这个输出是未定义的,原因也是函数参数求值顺序的问题,并不是所谓的压栈什么.

关于这一节,我还是半知半解,需要深入研究,[相关博客](http://blog.csdn.net/zhongjiekangping/article/details/5164132)

##算术运算符
所谓算术运算符大致有`+,-,*,/,%`这几种,算术运算符需要注意的一个是溢出的问题,另一个就是带有负数的求模.

5%-2 = x, 5/-2 = -2(向0取整), 所以x = 1

-5%2 = x, -5/2 = -2(向0取整), 所以x = -1

-5%-2 = x, -5/-2 = 2(向0取整), 所以x = -1

##逻辑运算符
&&和||最著名的就是短路求值原则.

##关系运算符
关系运算符满足左结合律,所以当你看到`i<j<k`这样的表达式时候不要惊慌,虽然这种写法很奇葩,多数情况是理解有误才写出来的,因为它先计算i<j得到0/1,再判断与k的大小关系.

##赋值运算符
赋值运算符满足右结合律,可以连续赋值.

##条件运算符
条件运算符是右结合的,有明确的求值顺序,先判断条件,再根据条件计算相应子表达式.

##位运算符
位运算符的操作都是基于补码之上的,而且对整型数据有效,对浮点型无效,常见的有`&,?,~,^,<<,>>`,其中关于移位运算符需要说明一下:

*	左移:	右边补0
*	右移:	如果是无符号数,左边补0,如果是有符号数补符号位(其实貌似也是和编译器有关系)

##sizeof运算符
这里再次强调一点,sizeof是运算符!!!不是函数,可以直接sizeof data,它用来统计类型或者变量的内存大小,对数组名会计算整个数组的内存大小,对指针等类型名只是计算本身大小,对vector/string的对象只计算其固定部分的大小,不会计算容器存放的元素大小.

##逗号运算符
规定了求值顺序,从左到右.









##类型转换
###隐式类型转换
自动执行的转换,比如多个算术类型之间的转换等,条件判断时候整型到bool型的转换,函数调用时候等.

####无符号类型与有符号类型的转换
在算术计算时候,遇到无符号和有符号类型时候,到底谁转换为谁本着以下两条规则:

*	无符号类型的数字范围在有符号类型的数字范围,那么一般来说是无符号转为有符号(根据机器). 例如 unsigned char 和 int
*	无符号类型的数字范围超出有符号类型的数字范围,那么有符号转为无符号. 例如 unsigned int 和 int


###显式类型转换
主要有四种static_cast, dynamic_cast, reinterpret_cast和const_cast

|类型|说明|备注|
|:----:|:----:|:----:|
|static_cast|有明确定义的转换都可以用它,例如算术类型之间的转换,基类和派生类指针之间的转换|静态的检查,在基类指针转为派生类指针时候可以编译通过,但是可能会有问题|
|dynamic_cast|主要用于基类和派生类指针之间的转化|会进行动态检查,基类指针转为派生类指针时候,必须要求基类有虚函数,更加安全一些|
|reinterpret_cast|一些底层的转换,像int*转为char*|非常不安全|
|const_cast|用来解除const性||

旧式的C语言风格的转换方法例如`char* c = (int*)p`其实和reinterpret_cast是一样的,不推荐使用,因为不容易被发现,调试困难.
