#泛型算法
泛型算法是定义在容器的迭代器之上的通用性算法.**泛型算法永远不会改变底层容器的大小(即不会添加和删除)**,想删除或者添加需要调用容器自己的成员函数.

##泛型算法种类
###只读算法
这类算法通常只会读取相应范围内的容器值,从不改变容器的值.像accumulate,equal等等.它们或是操作一个容器或是操作两个容器,操作一个容器的一般给出容器范围的起止迭代器;操作两个容器的一般给出第一个容器的起止迭代器和第二个容器的起迭代器.
###写容器元素算法
这类算法会写容器的值,像fill算法等.像目的位置迭代器写入数据的算法假定目的位置足够大,能容纳要写入的元素.
###拷贝算法
这类算法会从一个迭代器指向的范围拷贝数据到另外一个迭代器指向的范围.像copy,replace_copy等
###重排容器元素顺序算法
这类算法会改变容器中元素的顺序,像sort算法这类.

##定制操作
很多算法,允许提供自定义的操作,像sort算法,可以为它提供比较函数,这些定制操作统称为谓词,谓词有两类分别是一元谓词和二元谓词,且谓词参数的类型必须能由元素类型转换.
```C++
bool comp(int i, int j){
	return i < j;
}

vector<int> v = {2,3,3,6,5};
sort(v.begin(), v.end(), comp);
//也可以使用通用算法
//sort(v.begin(), v.end(), greater<int>());

```

##lambda表达式
lambda表达式实际上就是一种匿名的内联函数,它可以有捕获列表,参数列表,函数实体,返回值类型等,这里水很深,就简单举个例子看一下,关于它的东西可以查阅资料再深入研究.
```C++
vector<int> v = {3,4,5,1,3};
//不带捕获列表的lambda表达式
sort(v.begin(), v.end(), [](int i, int j){ return i < j;});

int sz = 2;
//不带捕获列表(sz)的lambda表达式
sort(v.begin(), v.end(), [sz](int i, int j){ return i%sz < j%sz;});

```

##再探迭代器
*	标准库在头文件iterator中还定义几个额外的迭代器:
	*	插入迭代器
	*	流迭代器: istream_iterator和ostream_iterator
	*	反向迭代器
	*	移动迭代器	
*	泛型算法中五类迭代器
	*	输入迭代器: 支持==, !=, ++, *(是const的)
	*	输出迭代器:	支持++, *
	*	前向迭代器:	支持++, 可以读写
	*	双向迭代器:	支持++, --, 可以读写
	*	随机迭代器:	支持++, --, +, -, [], <, <=等, 可以读写
